.text

# Function: Card-generator
# Parameter: $a0, which contains card number
# Description: generates 32 numbers for each card according to the card number, and store it into a card array

Card_generator:
	li $t0, 0 # $t0 contains from 0 to 31 through looping
	li $a3, 0 # $a4 contains index of the card array

loop:	bgt $t0, 31, exit_loop
	
	move $t1, $t0  # $t1 contains content of card after manipulation
	
	#manipulation
	addi $a1, $a0, -1 # $a1 contains card_num - 1
	li $a2, 1
	sllv $a2, $a2, $a1 # $a2 contains 1 shft left by card_num-1
	
	div $t0, $a2
	mflo $t1 # $t1 contains left part
	mfhi $t2 # $t2 contains right part
	
	sllv $t1, $t1, $a0  # left part shft left by card_num
	add $t1, $t1, $a2   # then add $a2, which is 1 shft left by card_num-1
	add $t1, $t1, $t2   # lhen add right part, so $t1 contains the correct content of the card (one word)
	
	# load the correct content into the memory
	sw $t1, card($a3)
	
	# increment #t0 by 1 and $a3 by 4 and jump back to looping
	addi $a3, $a3, 4
	addi $t0, $t0, 1
	
	j loop

exit_loop:
	jr $ra

# Function : Accumulation
# parameter: $a0 contains card number
#	     $a1 contains user's input of 1/0 (yes/no)
#	     $a2 contains previously accumulated value
#
# return   : $v0 contains accumulated value
# Description : accumulate the answer according to index of card and return the answer
# 		whenever the input is yes, we need to add " 1 sft left by card number - 1" to the answer
# 		if the answer is no, we do nothing

Accumulator:
	# determine the input
	beq $a1, $zero, skip
	
	# get card number - 1
	addi $a0, $a0, -1
	
	# 1 shft left by "card number - 1"
	li $t6, 1
	sllv $t6, $t6, $a0 
	
	# accumulate the value
	add $a2, $a2, $t6
	
skip:
	move $v0, $a2  #$v0 contains accumulated value to return
	
	jr $ra

# Function: Yes_no_prompter
# Parameter: none
# Return:  $v0 contains answer of yes/no (1/0)
# Description: 
Yes_no_prompter:

prompt:
	li $v0, 50
	la $a0, yes_no_prompt
	syscall
	beq $a0, 0, return_yes
	beq $a0, 1, return_no
	beq $a0, 2, good_bye
	
return_yes:
	li $v0, 1
	jr $ra
	
return_no:
	li $v0, 0
	jr $ra
	


# Function: Print_card_content
# Parameter: None
# Return: None
# Description: using value generated by Card_generator and print it into an aligned table format

Print_card_content:
	# first thing first, add a new line
	li $v0, 4
        la $a0, new_line
        syscall
	
	# Initialize variable
	li $t0, 0   # $t0 contains index of card array that points to one piece of content in a card
	li $t7, 0   # $t7 contains counter of number of numbers within a line
	li, $t5, 7  # $t5 contains maximum numbers within of line
       
while:	beq  $t0, 128, exit
        lw $t6, card($t0)  # $t6 contains content of card
        addi $t0, $t0, 4   # point to the next number
            
        # print content of card
	li $v0, 1
	move $a0, $t6
	syscall
            
	# Check to see if one space is needed to be added or two spaces
	bgt $t6, 9, add_one_space
	li $v0, 4
	la $a0, two_spaces
	syscall
        
	j Check_next_line # check whether or not to add new line
            
add_one_space:     
	li $v0, 4
        la $a0, one_space
        syscall
        
Check_next_line:
        #new line creator
        beq $t7,$t5 , add_new_line
        addi $t7, $t7, 1
           
        j while
 
add_new_line:
	li $v0, 4
        la $a0, new_line
        syscall
        
        li $t7, 0  # reset $t7 (counter of number of numbers within a line) back to 0  
        j while
exit:
        jr $ra # go back to main

# Function: Sound_maker
# Description: create a midi sound that plays when user enters inavlid or dessapointing result	
Sound_maker:

       li $v0, 31 
       la $a0, pitch
       la $a1, duration
       la $a2, instrument
       la $a3, volume
       syscall
       
       jr $ra

     
#Function: Random card generator
#Description: Card number goes from 1 to 6 which is randomized and then stored into card number list aarray
number_list: 
reset_values:
     li $t9, 24
     reset: 
         blt $t9, $zero, out
         sw $zero, card_number_list($t9)
         subi $t9, $t9, 4
         j reset     
     
out:     
     
     
     li $t1, 0
   
    random:
          beq $t1, 24, ext
          li $v0, 42
          li $a1, 7
          li $a0,1
          syscall
   
         li $t5, 0
    compare:  
         beq $t5, 24, store
         lw $t6, card_number_list($t5)
         beq $a0, $t6, do_not_store
         addi $t5, $t5, 4
         j compare
   
    store:
        sw $a0, card_number_list($t1)
        addi $t1,$t1, 4
        j random

     do_not_store:
        j random
    
     ext:
        jr $ra

     
