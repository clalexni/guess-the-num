.text

# Function: Card-generator
# Parameter: $a0, which contains card number
# Description: generates 32 numbers for each card according to the card number, and store it into a card array

Card_generator:
	li $t0, 0 # $t0 contains from 0 to 31 through looping
	li $a3, 0 # $a4 contains index of the card array

loop:	bgt $t0, 31, exit_loop
	
	move $t1, $t0  # $t1 contains content of card after manipulation
	
	#manipulation
	addi $a1, $a0, -1 # $a1 contains card_num - 1
	li $a2, 1
	sllv $a2, $a2, $a1 # $a2 contains 1 shft left by card_num-1
	
	div $t0, $a2
	mflo $t1 # $t1 contains left part
	mfhi $t2 # $t2 contains right part
	
	sllv $t1, $t1, $a0  # left part shft left by card_num
	add $t1, $t1, $a2   # then add $a2, which is 1 shft left by card_num-1
	add $t1, $t1, $t2   # lhen add right part, so $t1 contains the correct content of the card (one word)
	
	# load the correct content into the memory
	sw $t1, card($a3)
	
	# increment #t0 by 1 and $a3 by 4 and jump back to looping
	addi $a3, $a3, 4
	addi $t0, $t0, 1
	
	j loop

exit_loop:
	jr $ra

# Function : Accumulation
# parameter: $a0 contains card number
#	     $a1 contains user's input of 1/0 (yes/no)
#	     $a2 contains previously accumulated value
#
# return   : $v0 contains accumulated value
# Description : accumulate the answer according to index of card and return the answer
# 		whenever the input is yes, we need to add " 1 sft left by card number - 1" to the answer
# 		if the answer is no, we do nothing

Accumulator:
	# determine the input
	beq $a1, $zero, skip
	
	# get card number - 1
	addi $a0, $a0, -1
	
	# 1 shft left by "card number - 1"
	li $t6, 1
	sllv $t6, $t6, $a0 
	
	# accumulate the value
	add $a2, $a2, $t6
	
skip:
	move $v0, $a2  #$v0 contains accumulated value to return
	
	jr $ra

# Function: Yes_no_prompter
# Parameter: none
# Return:  $v0 contains answer of yes/no (1/0)
# Description: Keep prompting user to input yes or no, and return the answer. Display error message if input is not as expected
Yes_no_prompter:

prompt:
	#read input as character
	li $v0, 12
	syscall
	
	# load character byte 'y' and 'n' to compare with input
	li $t1, 'y'
	li $t0, 'n'
	
	beq $v0, $t1, return_yes
	beq $v0, $t0, return_no
	
	# if answer is not 'y' or 'n'
	j error_message
	
return_yes:
	li $v0, 1
	jr $ra
	
return_no:
	li $v0, 0
	jr $ra
	
error_message:
	li, $v0, 4
	la $a0, error_message_prompt
	syscall
	
	j prompt

# Function: Print_card_content
# Parameter: None
# Return: None
# Description: using value generated by Card_generator and print it into an aligned table format

Print_card_content:
	# first thing first, add a new line
	li $v0, 4
        la $a0, new_line
        syscall
	
	# Initialize variable
	li $t0, 0   # $t0 contains index of card array that points to one piece of content in a card
	li $t7, 0   # $t7 contains counter of number of numbers within a line
	li, $t5, 7  # $t5 contains maximum numbers within of line
       
while:	beq  $t0, 128, exit
        lw $t6, card($t0)  # $t6 contains content of card
        addi $t0, $t0, 4   # point to the next number
            
        # print content of card
	li $v0, 1
	move $a0, $t6
	syscall
            
	# Check to see if one space is needed to be added or two spaces
	bgt $t6, 9, add_one_space
	li $v0, 4
	la $a0, two_spaces
	syscall
        
	j Check_next_line # check whether or not to add new line
            
add_one_space:     
	li $v0, 4
        la $a0, one_space
        syscall
        
Check_next_line:
        #new line creator
        beq $t7,$t5 , add_new_line
        addi $t7, $t7, 1
           
        j while
 
add_new_line:
	li $v0, 4
        la $a0, new_line
        syscall
        
        li $t7, 0  # reset $t7 (counter of number of numbers within a line) back to 0  
        j while
exit:
        jr $ra # go back to main

